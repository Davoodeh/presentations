#+TITLE: literate_programming
#+AUTHOR: Niklas Carlsson

* Basics

| Command                 | Action |
|-------------------------+--------|
| this is a command       | g      |
| this is another command | gg     |

Link to website
[[https://orgmode.org/][link to org mode]]

Link to global file
[[file:~/.config/doom/init.el::(evil%20+everywhere);%20come%20to%20the%20dark%20side,%20we%20have%20cookies][evil everywhere]]

Pretty bullets:
https://thraxys.wordpress.com/2016/01/14/pimp-up-your-org-agenda/

Org-hide leading stars

* Babel

** Source code blocks
Activate with ~<s~

#+BEGIN_SRC sh
cd ~/org
ls
#+END_SRC

To activate mode specific window ~C-c '~

#+BEGIN_SRC python :results output :session my-python-session :var number=32
for i in range(number):
    print(i)
#+END_SRC

#+RESULTS:
#+begin_example
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
#+end_example

** Session

#+BEGIN_SRC sh :session my-shell-session
env_var="org"
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :session my-shell-session
echo $env_var
#+END_SRC

#+RESULTS:
: org

** Noweb

First let's define our variables:

#+NAME: python-definition
#+BEGIN_SRC python
number = 32
#+END_SRC

Then let's create our implementation:

#+NAME: python-implementation
#+BEGIN_SRC python
for i in range(number):
    print(i)
#+END_SRC

And the final implementation will look like:

Tangle is nice to be able to create a physical file of the block. ~C-u
org-babel-tangle~.

#+BEGIN_SRC python :noweb yes :results output :tangle ~/temp/my_test.py
# Our definition
<<python-definition>>
# Our implementation
<<python-implementation>>
<<ripgrep-path()>>
#+END_SRC

#+RESULTS:
#+begin_example
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
/usr/bin/rg
#+end_example

It's also possible to mix languages:
#+NAME:ripgrep-path
#+BEGIN_SRC elisp :results value
(message "print(\"%s\")" (executable-find "rg"))
#+END_SRC

** PlantUML

#+BEGIN_SRC plantuml :file ~/temp/org-plant-1.png
@startuml
class Car

Driver - Car : drives >
Car *- Wheel : have 4 >
Car -- Person : < owns

@enduml
#+END_SRC

#+RESULTS:
[[file:~/temp/org-plant-1.png]]

** TRAMP

#+BEGIN_SRC sh :dir /docker:priceless_payne:/
ls
#+END_SRC

#+RESULTS:
| [1;34mapp[m  | [1;34mlib[m             | [1;34mroot[m | [1;34mtmp[m |
| [1;34mbin[m  | [1;34mmedia[m           | [1;34mrun[m  | [1;34musr[m |
| [1;34mdev[m  | [1;34mmnt[m             | [1;34msbin[m | [1;34mvar[m |
| [1;34metc[m  | [1;34mproc[m            | [1;34msrv[m  |                 |
| [1;34mhome[m | [0;0mrequirements.txt[m | [1;34msys[m  |                 |

** Python


#+BEGIN_SRC python :session :results file
import numpy as np
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt
graylevel = 0.75
fig=plt.figure(figsize=(3,2))
X = np.linspace(0, 7, 10000)
plt.plot(X, 4 * np.sin(X))
plt.plot(X, 5 * np.cos(X))
fig.tight_layout()
plt.savefig('myfig2.png')
'myfig2.png' # return this to org-mode
#+END_SRC

#+RESULTS:
[[file:myfig2.png]]


For automatically redisplay images:
#+BEGIN_SRC elisp
(add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+END_SRC
** C++

#+BEGIN_SRC C++
#include <iostream>

int main(int argc, char *argv[]) {
    std::cout << "Hello world" << std::endl;
    return 0;
}
#+END_SRC

#+RESULTS:
: Hello world

#+BEGIN_SRC C++ :flags '("-I ~/Dropbox/Code/Eigen") :results output
#include <iostream>
#include <Eigen/Dense>

int main(int argc, char *argv[]) {
    Eigen::MatrixXd mat = Eigen::MatrixXd::Random(3, 5);
    std::cout << "mat = " << mat << std::endl;
    return 0;
}
#+END_SRC

#+RESULTS:
: mat =   0.680375    0.59688  -0.329554    0.10794  -0.270431
:  -0.211234   0.823295   0.536459 -0.0452059  0.0268018
:   0.566198  -0.604897  -0.444451   0.257742   0.904459


#+BEGIN_SRC C++ :includes '(<vector> <numeric> <iostream>) :flags -std=c++11
  std::vector<int> v( 100 );
  std::iota( std::begin( v ), std::end( v ), 0 );
  std::cout << v[7] << std::endl;
  std::cout << v[99] << std::endl;
#+END_SRC

#+RESULTS:
|  7 |
| 99 |

** Eshell

To get eshell in org-mode babel install this:

#+BEGIN_SRC elisp
;;; ob-eshell.el --- Babel Functions for Eshell            -*- lexical-binding: t; -*-

;; Copyright (C) 2009-2018 Free Software Foundation, Inc.

;; Author: stardiviner <numbchild@gmail.com>
;; Keywords: literate programming, reproducible research
;; Homepage: https://orgmode.org

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; Org Babel support for evaluating Eshell source code.

;;; Code:
(require 'ob)
(require 'eshell)

(defvar org-babel-default-header-args:eshell '())

(defun org-babel-execute:eshell (body params)
  "Execute a block of Eshell code BODY with PARAMS.
This function is called by `org-babel-execute-src-block'.

The BODY can be any code which allowed executed in Eshell.
Eshell allow to execute normal shell command and Elisp code.
More details please reference Eshell Info.

The PARAMS are variables assignments."
  (let* ((session (org-babel-eshell-initiate-session
                   (cdr (assq :session params))))
         (full-body (org-babel-expand-body:generic
                     body params (org-babel-variable-assignments:eshell params))))
    (if session
        (progn
          (with-current-buffer session
            (dolist (line (split-string full-body "\n"))
              (goto-char eshell-last-output-end)
              (insert line)
              (eshell-send-input))
            ;; get output of last input
            ;; TODO: collect all output instead of last command's output.
            (goto-char eshell-last-input-end)
            (buffer-substring-no-properties (point) eshell-last-output-start)))
      (with-temp-buffer
        (eshell-command full-body t)
        (buffer-string)))))

(defun org-babel-prep-session:eshell (session params)
  "Prepare SESSION according to the header arguments specified in PARAMS."
  (let* ((session (org-babel-eshell-initiate-session session))
         ;; Eshell session buffer is read from variable `eshell-buffer-name'.
         (eshell-buffer-name session)
         (var-lines (org-babel-variable-assignments:eshell params)))
    (call-interactively #'eshell)
    (mapc #'eshell-command var-lines)
    session))

(defun ob-eshell-session-live-p (session)
  "Non-nil if Eshell SESSION exists."
  (get-buffer session))

(defun org-babel-eshell-initiate-session (&optional session params)
  "Initiate a session named SESSION according to PARAMS."
  (when (and session (not (string= session "none")))
    (save-window-excursion
      (or (ob-eshell-session-live-p session)
          (progn
            (let ((eshell-buffer-name session))
              (eshell))
            (get-buffer (current-buffer)))))
    session))

(defun org-babel-variable-assignments:eshell (params)
  "Convert ob-eshell :var specified variables into Eshell variables assignments."
  (mapcar
   (lambda (pair)
     (format "(setq %s %S)" (car pair) (cdr pair)))
   (org-babel--get-vars params)))

(defun org-babel-load-session:eshell (session body params)
  "Load BODY into SESSION with PARAMS."
  (save-window-excursion
    (let ((buffer (org-babel-prep-session:eshell session params)))
      (with-current-buffer buffer
        (goto-char (point-max))
        (insert (org-babel-chomp body)))
      buffer)))

(provide 'ob-eshell)

;;; ob-eshell.el ends here

#+END_SRC

Execute commands:

#+BEGIN_SRC eshell :dir ~/ :session my-eshell-session
ls
#+END_SRC

#+RESULTS:
: bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
