* Literate programming in Org-mode
** DONE Org-mode
CLOSED: [2018-11-19 Mon 14:37]

The first thing I will do is to show how an ~.org~ file looks in
fundamental-mode. It's actually nothing more than a text file.

*** Content

Here are some of the basics we can have a look at:

- Headings, how to create them and change them
- What kinds of lists are supported
- How tables look like
- TODO:s


**** My favorite things
1) That it's just plain text files
2) It's automatic adjustments

**** Commands

Good to know commands in Org-mode

| Commannd          | Action          |
|-------------------+-----------------|
| Tab heading       | Demotes heading |
| Shift-Tab heading | Promote heading |
| C-Enter           |                 |
| M-Enter           |                 |

** Literate programming

#+BEGIN_SRC sh
echo "hello there!"
#+END_SRC

#+RESULTS:
: hello there!

#+BEGIN_SRC elisp
(format "hello there")
#+END_SRC

#+RESULTS:
: hello there

#+BEGIN_SRC python
print("hello there")
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python
return "hello there"
#+END_SRC

#+RESULTS:
: hello there

#+BEGIN_SRC python :results output
print("hello there")
#+END_SRC

#+RESULTS:
: hello there

#+BEGIN_QUOTE
Org returns the contents of the standard output stream as as text results.
#+END_QUOTE

** Arguments
** Sessions
** Tangling
** Note taking

I started to take notes with Org-mode and soon I found myself reading a
programming book and realized how greatly suited Org is for that usecase.

I will open my notes file that I have and navigate to a section with notes from
the book

With Org-mode I can then easily take notes and experiment with the programming
examples that exists in the book. For me that is a perfect match which makes it
much easier for me to grasp the concepts.

However now when I am reading the notes in hindsight they aren't as clear as
they where when I took them. I think what I am missing is the actual context
from within they where taken. I guess I need to open the pdf and look for clues.

That would be if I didn't have Org-mode ... But with the package ~Org-Noter~ I
get exactly this. So I will call the function ~M-x org-noter~ and I
automatically get a split view with my notes and with the actual pdf file.
[[file:~/org/hacking_notebook.org::*The%20if%20Special%20Form][An introduction to Elisp: The if Special Form]]

Even though linking to other files is useful I am again feeling that I am
lacking the context sometimes. Sure it's useful if I want to reference the whole
file but not if there is a subpart of it. Luckily there is a cool solution to
that which involves ~org-capture~
** Docker

I don't build Docker images that often so it would be really useful if I could
document the procedure both for later reference. On Arch Linux I don't
have [[https://www.docker.com/][Docker]] installed so that is the first step.

*** Installation

I found docker related instructions on the [[https://wiki.archlinux.org/index.php/docker][arch wiki]]. So first we install docker
with the package manager:
#+BEGIN_SRC sh
sudo pacman -S docker
#+END_SRC

Next we start the docker service
#+BEGIN_SRC sh :dir "/sudo::" :results none
sudo systemctl start docker
#+END_SRC

Now we want to make sure that the docker can be run as expected. I will use the
~hello-world~ image to try that out
#+BEGIN_SRC sh :results raw
docker run hello-world
#+END_SRC

Unfortunately this gives an error with the following message:
#+BEGIN_EXAMPLE
docker: Got permission denied while trying to connect to the Docker daemon
socket at unix:///var/run/docker.sock: Post
http://%2Fvar%2Frun%2Fdocker.sock/v1.39/containers/create: dial unix
/var/run/docker.sock: connect: permission denied.
See 'docker run --help'.
#+END_EXAMPLE

[[https://techoverflow.net/2017/03/01/solving-docker-permission-denied-while-trying-to-connect-to-the-docker-daemon-socket/][This]] article discusses the same problem and it seems like it can be solved if I
get evalated rights. That can be achieved by letting me be part of the group docker.
I currently belong to these groups:
#+BEGIN_SRC sh
groups niklascarlsson
#+END_SRC

#+RESULTS:
: vboxsf niklascarlsson

But I want to belong to the docker group as well, so I will need to run a
command to achieve that. It will require me to use sudo which we can achieve
thanks to ~TRAMP~
#+BEGIN_SRC sh :dir "/sudo::""
sudo gpasswd -a niklascarlsson docker
#+END_SRC

#+RESULTS:
: Adding user niklascarlsson to group docker

Let's verify that it worked:
#+BEGIN_SRC sh
groups niklascarlsson
#+END_SRC

#+RESULTS:
: vboxsf docker niklascarlsson

In order for it to really take effect we need to either logout or reboot. So I
will reboot in order to get my permissions. Now we are back and can run the
~hello-world~ again:
#+BEGIN_SRC sh :results output
docker run hello-world
#+END_SRC

#+RESULTS:
#+begin_example

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

#+end_example

Perfect, we have a working docker installation. Now let's build ourselves an image.

*** Build a Python3 image
:PROPERTIES:
:header-args: :results output :mkdirp yes
:END:

I would like to build a docker image with ~Python3~ installed so that I can run
my python3 code. I got the inspiration from this [[https://blog.realkinetic.com/building-minimal-docker-containers-for-python-applications-37d0272c52f3][minimal docker image]] example.

**** Requirements

We need to specify the requirements that we are demanding:
#+BEGIN_SRC text :tangle minimal_python_docker/requirements.txt
Flask>=0.12,<0.13
flask-restplus>=0.9.2,<0.10
Flask-SSLify>=0.1.5,<0.2
Flask-Admin>=1.4.2,<1.5
gunicorn>=19,<20
#+END_SRC

By using the ~mkdirp~ setting I am able to automatically create the needed
directory structure.

**** Dockerfile

The ~Dockerfile~
#+BEGIN_SRC text :tangle minimal_python_docker/Dockerfile
FROM python:3.6-alpine

COPY requirements.txt /

RUN pip install -r /requirements.txt

COPY src/ /app
WORKDIR /app

CMD ["python", "app.py"]
#+END_SRC

**** The application

#+BEGIN_SRC python :tangle minimal_python_docker/src/app.py
for i in range(20):
    print "i has the value " + str(i)
#+END_SRC

**** Create the image

#+BEGIN_SRC sh :dir minimal_python_docker
docker build -t niklascarlsson/minimal_python3 .
#+END_SRC

#+RESULTS:
#+begin_example
Sending build context to Docker daemon  4.608kB
Step 1/6 : FROM python:3.6-alpine
3.6-alpine: Pulling from library/python
4fe2ade4980c: Pulling fs layer
7cf6a1d62200: Pulling fs layer
bd5bf1aa7305: Pulling fs layer
73e1cfb346e5: Pulling fs layer
1e70e0bfa6e9: Pulling fs layer
73e1cfb346e5: Waiting
1e70e0bfa6e9: Waiting
7cf6a1d62200: Verifying Checksum
7cf6a1d62200: Download complete
4fe2ade4980c: Verifying Checksum
4fe2ade4980c: Download complete
73e1cfb346e5: Verifying Checksum
73e1cfb346e5: Download complete
4fe2ade4980c: Pull complete
7cf6a1d62200: Pull complete
1e70e0bfa6e9: Verifying Checksum
1e70e0bfa6e9: Download complete
bd5bf1aa7305: Verifying Checksum
bd5bf1aa7305: Download complete
bd5bf1aa7305: Pull complete
73e1cfb346e5: Pull complete
1e70e0bfa6e9: Pull complete
Digest: sha256:efdc898dcd3934564489a933f13a51f136960e63d779ca88750cfe07add65c22
Status: Downloaded newer image for python:3.6-alpine
 ---> 1d981af1e3b4
Step 2/6 : COPY requirements.txt /
 ---> a75afff4ca55
Step 3/6 : RUN pip install -r /requirements.txt
 ---> Running in cd7546f2498a
Collecting Flask<0.13,>=0.12 (from -r /requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/2e/48/f1936dadac2326b3d73f2fe0a964a87d16be16eb9d7fc56f09c1bea3d17c/Flask-0.12.4-py2.py3-none-any.whl (81kB)
Collecting flask-restplus<0.10,>=0.9.2 (from -r /requirements.txt (line 2))
  Downloading https://files.pythonhosted.org/packages/e3/cf/f17666fe32180cc6f06ed9ff3dd18732a77919f04e47d4661c06cc97c49c/flask_restplus-0.9.2-py2.py3-none-any.whl (903kB)
Collecting Flask-SSLify<0.2,>=0.1.5 (from -r /requirements.txt (line 3))
  Downloading https://files.pythonhosted.org/packages/6e/98/54f2ffaf886d25eb1591cfb534c04cbf983236d657d58d180fd9ccbb5e7f/Flask-SSLify-0.1.5.tar.gz
Collecting Flask-Admin<1.5,>=1.4.2 (from -r /requirements.txt (line 4))
  Downloading https://files.pythonhosted.org/packages/74/23/a411ce6bca79f30698fbe1d1a59c4789919bdb93fb5385bb24ea07ea7674/Flask-Admin-1.4.2.tar.gz (922kB)
Collecting gunicorn<20,>=19 (from -r /requirements.txt (line 5))
  Downloading https://files.pythonhosted.org/packages/8c/da/b8dd8deb741bff556db53902d4706774c8e1e67265f69528c14c003644e6/gunicorn-19.9.0-py2.py3-none-any.whl (112kB)
Collecting itsdangerous>=0.21 (from Flask<0.13,>=0.12->-r /requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/76/ae/44b03b253d6fade317f32c24d100b3b35c2239807046a4c953c7b89fa49e/itsdangerous-1.1.0-py2.py3-none-any.whl
Collecting click>=2.0 (from Flask<0.13,>=0.12->-r /requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/fa/37/45185cb5abbc30d7257104c434fe0b07e5a195a6847506c074527aa599ec/Click-7.0-py2.py3-none-any.whl (81kB)
Collecting Jinja2>=2.4 (from Flask<0.13,>=0.12->-r /requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/7f/ff/ae64bacdfc95f27a016a7bed8e8686763ba4d277a78ca76f32659220a731/Jinja2-2.10-py2.py3-none-any.whl (126kB)
Collecting Werkzeug>=0.7 (from Flask<0.13,>=0.12->-r /requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/20/c4/12e3e56473e52375aa29c4764e70d1b8f3efa6682bef8d0aae04fe335243/Werkzeug-0.14.1-py2.py3-none-any.whl (322kB)
Collecting aniso8601>=0.82 (from flask-restplus<0.10,>=0.9.2->-r /requirements.txt (line 2))
  Downloading https://files.pythonhosted.org/packages/69/9b/f2ae61c0c90181b62e15ca09d283d2aab42c7c2c3bbd7c548dd0cfd8bf3e/aniso8601-4.0.1-py2.py3-none-any.whl
Collecting pytz (from flask-restplus<0.10,>=0.9.2->-r /requirements.txt (line 2))
  Downloading https://files.pythonhosted.org/packages/f8/0e/2365ddc010afb3d79147f1dd544e5ee24bf4ece58ab99b16fbb465ce6dc0/pytz-2018.7-py2.py3-none-any.whl (506kB)
Collecting six>=1.3.0 (from flask-restplus<0.10,>=0.9.2->-r /requirements.txt (line 2))
  Downloading https://files.pythonhosted.org/packages/67/4b/141a581104b1f6397bfa78ac9d43d8ad29a7ca43ea90a2d863fe3056e86a/six-1.11.0-py2.py3-none-any.whl
Collecting jsonschema (from flask-restplus<0.10,>=0.9.2->-r /requirements.txt (line 2))
  Downloading https://files.pythonhosted.org/packages/77/de/47e35a97b2b05c2fadbec67d44cfcdcd09b8086951b331d82de90d2912da/jsonschema-2.6.0-py2.py3-none-any.whl
Collecting wtforms (from Flask-Admin<1.5,>=1.4.2->-r /requirements.txt (line 4))
  Downloading https://files.pythonhosted.org/packages/9f/c8/dac5dce9908df1d9d48ec0e26e2a250839fa36ea2c602cc4f85ccfeb5c65/WTForms-2.2.1-py2.py3-none-any.whl (166kB)
Collecting MarkupSafe>=0.23 (from Jinja2>=2.4->Flask<0.13,>=0.12->-r /requirements.txt (line 1))
  Downloading https://files.pythonhosted.org/packages/ac/7e/1b4c2e05809a4414ebce0892fe1e32c14ace86ca7d50c70f00979ca9b3a3/MarkupSafe-1.1.0.tar.gz
Building wheels for collected packages: Flask-SSLify, Flask-Admin, MarkupSafe
  Running setup.py bdist_wheel for Flask-SSLify: started
  Running setup.py bdist_wheel for Flask-SSLify: finished with status 'done'
  Stored in directory: /root/.cache/pip/wheels/f6/be/7c/b262753258e34b3f07ec47973038f199c34678985b9614a50d
  Running setup.py bdist_wheel for Flask-Admin: started
  Running setup.py bdist_wheel for Flask-Admin: finished with status 'done'
  Stored in directory: /root/.cache/pip/wheels/49/d4/b3/8edf3699b2ea1c5e32fd4cce5ae3395a3aa198399fc82f9c46
  Running setup.py bdist_wheel for MarkupSafe: started
  Running setup.py bdist_wheel for MarkupSafe: finished with status 'done'
  Stored in directory: /root/.cache/pip/wheels/81/23/64/51895ea52825dc116a55f37043f49be0939bcf603de54e5cde
Successfully built Flask-SSLify Flask-Admin MarkupSafe
Installing collected packages: itsdangerous, click, MarkupSafe, Jinja2, Werkzeug, Flask, aniso8601, pytz, six, jsonschema, flask-restplus, Flask-SSLify, wtforms, Flask-Admin, gunicorn
Successfully installed Flask-0.12.4 Flask-Admin-1.4.2 Flask-SSLify-0.1.5 Jinja2-2.10 MarkupSafe-1.1.0 Werkzeug-0.14.1 aniso8601-4.0.1 click-7.0 flask-restplus-0.9.2 gunicorn-19.9.0 itsdangerous-1.1.0 jsonschema-2.6.0 pytz-2018.7 six-1.11.0 wtforms-2.2.1
Removing intermediate container cd7546f2498a
 ---> 363588b44974
Step 4/6 : COPY src/ /app
 ---> 8a4ebf7146c3
Step 5/6 : WORKDIR /app
 ---> Running in 3ae724d0f30e
Removing intermediate container 3ae724d0f30e
 ---> 31a745587249
Step 6/6 : CMD ["python", "app.py"]
 ---> Running in 34c9a66cde77
Removing intermediate container 34c9a66cde77
 ---> b3db662ee473
Successfully built b3db662ee473
Successfully tagged niklascarlsson/minimal_python3:latest
#+end_example

First we verify that the image is now available among the docker images
#+BEGIN_SRC sh
docker images
#+END_SRC

#+RESULTS:
: REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE
: niklascarlsson/minimal_python3   latest              b3db662ee473        14 seconds ago      101MB
: python                           3.6-alpine          1d981af1e3b4        4 days ago          74.3MB
: hello-world                      latest              4ab4c602aa5e        2 months ago        1.84kB

Nice, let's try the image
#+BEGIN_SRC sh :session org-docker-minimal-error
docker run niklascarlsson/minimal_python3
#+END_SRC

#+RESULTS:
:
: File "app.py", line 2
:     print "i has the value " + str(i)
:                            ^
: SyntaxError: invalid syntax

**** Oh no...

There is an issue. The python code we wrote where not compatible, let's
go back and fix that
#+BEGIN_SRC python :tangle minimal_python_docker/src/app.py
for i in range(20):
    print("i has the value " + str(i))
#+END_SRC

Let's rebuild
#+BEGIN_SRC sh :dir minimal_python_docker
docker build -t niklascarlsson/minimal_python3 .
#+END_SRC

#+RESULTS:
#+begin_example
Sending build context to Docker daemon  4.608kB
Step 1/6 : FROM python:3.6-alpine
 ---> 1d981af1e3b4
Step 2/6 : COPY requirements.txt /
 ---> Using cache
 ---> a75afff4ca55
Step 3/6 : RUN pip install -r /requirements.txt
 ---> Using cache
 ---> 363588b44974
Step 4/6 : COPY src/ /app
 ---> 0de70189b473
Step 5/6 : WORKDIR /app
 ---> Running in c55b43d214b6
Removing intermediate container c55b43d214b6
 ---> 2f19f74f4b84
Step 6/6 : CMD ["python", "app.py"]
 ---> Running in cb1badd5b6d9
Removing intermediate container cb1badd5b6d9
 ---> 50175d809b47
Successfully built 50175d809b47
Successfully tagged niklascarlsson/minimal_python3:latest
#+end_example

And test again:
#+BEGIN_SRC sh :session org-docker-minimal-error
docker run niklascarlsson/minimal_python3
#+END_SRC

#+RESULTS:
#+begin_example
i has the value 0
i has the value 1
i has the value 2
i has the value 3
i has the value 4
i has the value 5
i has the value 6
i has the value 7
i has the value 8
i has the value 9
i has the value 10
i has the value 11
i has the value 12
i has the value 13
i has the value 14
i has the value 15
i has the value 16
i has the value 17
i has the value 18
i has the value 19
#+end_example

Great we solved the issue!

*** Knock it up a notch
:PROPERTIES:
:header-args: :var docker_image="python3"
:END:

#+BEGIN_SRC sh :session org-docker-minimal-error :results none
docker run -it $docker_image /bin/sh
#+END_SRC

#+BEGIN_SRC sh :results table :post remove-first-line(tbl=*this*) :exports both
docker ps
#+END_SRC

#+NAME: running-docker-images
#+RESULTS:
| e43cafa84e96 | niklascarlsson/minimal_python3 | /bin/sh | 3 | minutes | ago | Up | 3 | minutes | peaceful_nash |
| e43cafa84e96 | niklascarlsson/minimal_python4 | /bin/sh | 3 | minutes | ago | Up | 3 | minutes | niklas        |

We can start with removing the first line that doesn't make sense
#+NAME: remove-first-line
#+BEGIN_SRC elisp :var tbl=""
(cdr tbl)
#+END_SRC

#+NAME: nick-name
#+BEGIN_SRC elisp :var tbl=running-docker-images :post set-image-nick-name(name=*this*)
(let ((elements nil)
      (name nil)
      (nick-name nil))
  (while tbl
    (setq elements (car tbl))
    (when (remove-if-not (lambda (element) (if (stringp element) (string-match docker_image element))) elements)
      (setq nick-name (last elements)))
    (setq tbl (cdr tbl)))
  nick-name)
#+END_SRC

#+RESULTS: nick-name
| peaceful_nash |

#+NAME: set-image-nick-name
#+BEGIN_SRC elisp :var name=""
(setq-local docker-run-name (format "/docker:%s:/" (car name)))
name
#+END_SRC

#+BEGIN_SRC sh :session my-docker-insider :dir (message docker-run-name) :results output
ls
#+END_SRC

#+RESULTS:
:
: $ [1;34mapp[m               [1;34mhome[m              [1;34mproc[m              [1;34msbin[m              [1;34musr[m
: [1;34mbin[m               [1;34mlib[m               [0;0mrequirements.txt[m  [1;34msrv[m               [1;34mvar[m
: [1;34mdev[m               [1;34mmedia[m             [1;34mroot[m              [1;34msys[m
: [1;34metc[m               [1;34mmnt[m               [1;34mrun[m               [1;34mtmp[m

#+BEGIN_SRC sh :session my-docker-insider :results output
cat requirements.txt
#+END_SRC

#+RESULTS:
:
: $ Flask>=0.12,<0.13
: =0.9.2,<0.10
: =0.1.5,<0.2
: =1.4.2,<1.5
: =19,<20

Let's change the app on the fly instead of having to rebuild

#+BEGIN_SRC sh :session my-docker-insider
cd app
ls
#+END_SRC

#+RESULTS:
|                                                 |
| $ /docker:boring_hermann:/ #$ [0;0mapp.py[m |

We can now run the python file directly from inside Org-mode
#+BEGIN_SRC sh :session my-docker-insider :results output
python app.py
#+END_SRC

#+RESULTS:
#+begin_example

$ i has the value 0
i has the value 1
i has the value 2
i has the value 3
i has the value 4
i has the value 5
i has the value 6
i has the value 7
i has the value 8
i has the value 9
i has the value 10
i has the value 11
i has the value 12
i has the value 13
i has the value 14
i has the value 15
i has the value 16
i has the value 17
i has the value 18
i has the value 19
#+end_example

Let's change it
#+BEGIN_SRC python :tangle (format "%s/app/app.py" docker-run-name)
print("hello")
#+END_SRC

#+BEGIN_SRC sh :session my-docker-insider :results output
python app.py
#+END_SRC

#+RESULTS:
:
: $ hello

I want to stop my running dockers
#+BEGIN_SRC sh :var name=nick-name :results output
docker ps
docker stop $name
docker rm $name
docker ps
#+END_SRC

#+RESULTS:
: CONTAINER ID        IMAGE                            COMMAND             CREATED             STATUS              PORTS               NAMES
: e43cafa84e96        niklascarlsson/minimal_python3   "/bin/sh"           27 minutes ago      Up 27 minutes                           peaceful_nash
: peaceful_nash
: peaceful_nash
: CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES


#+BEGIN_SRC sh :session org-docker-minimal-error :results none
docker run -it $docker_image /bin/sh
#+END_SRC

#+BEGIN_SRC sh
docker ps
#+END_SRC

#+RESULTS:
| CONTAINER    | ID                             | IMAGE   | COMMAND | CREATED | STATUS | PORTS | NAMES |         |               |
| e43cafa84e96 | niklascarlsson/minimal_python3 | /bin/sh |      10 | seconds | ago    | Up    |     9 | seconds | peaceful_nash |

#+BEGIN_SRC sh :session my-docker-insider2 :dir (message docker-run-name) :results output
cd app
python app.py
#+END_SRC

#+RESULTS:
#+begin_example

$ /docker:peaceful_nash:/ #$ /docker:peaceful_nash:/ #$ i has the value 0
i has the value 1
i has the value 2
i has the value 3
i has the value 4
i has the value 5
i has the value 6
i has the value 7
i has the value 8
i has the value 9
i has the value 10
i has the value 11
i has the value 12
i has the value 13
i has the value 14
i has the value 15
i has the value 16
i has the value 17
i has the value 18
i has the value 19
#+end_example

** Investigation
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usemintedstyle{paraiso-light}
Let's make a fun little investigation. Assume we have some data of a signal and
we want to make an algorithm that tracks the 1-d signal. This presentation is a
little bit too short to make a real algorithm and data in so we will fake it
instead
*** Synthesize the data
Let's use some Emacs lisp to generate the ground truth and the estimates for us:

#+BEGIN_SRC emacs-lisp :results value table :post addhdr(*this*) :exports both
  (mapcar (lambda (i)
            (list i (+ (random 4) (- i 2))))
          (number-sequence 1 20))
#+END_SRC

#+CAPTION: Truth and Estimate
#+NAME: est-truth-data
#+RESULTS:
|-------+----------|
| Truth | Estimate |
|-------+----------|
|     1 |        1 |
|     2 |        2 |
|     3 |        2 |
|     4 |        4 |
|     5 |        3 |
|     6 |        7 |
|     7 |        6 |
|     8 |        6 |
|     9 |        8 |
|    10 |        8 |
|    11 |       10 |
|    12 |       10 |
|    13 |       13 |
|    14 |       14 |
|    15 |       13 |
|    16 |       16 |
|    17 |       16 |
|    18 |       19 |
|    19 |       17 |
|    20 |       21 |

#+name: addhdr
#+begin_src emacs-lisp :var tbl=""
(cons 'hline (cons '("Truth" "Estimate") (cons 'hline tbl)))
#+end_src

Let's give the results a name so that we can reference the table later. It's
good to see the data in the table but I often find that some kind of
visualization is more powerful. It's too bad I don't know how to plot in
elisp... but I do know how to do it in Python.

*** Visualize estimate and truth
#+BEGIN_SRC python :session my-plot-session :var data=est-truth-data :results file :exports both
import numpy as np
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt

# Convert list to numpy array
truth = np.asarray(data)[:, 0]
est = np.asarray(data)[:, 1]
# Plot
fig=plt.figure()
plt.plot(truth, color="g", label="Truth")
plt.plot(est, marker="x", label="Estimate")
plt.legend(loc='upper left')
plt.xlabel("Sample")
plt.ylabel("Value")
plt.title("Tracking")
plt.savefig('.images/est_vs_truth.png')
'.images/est_vs_truth.png' # return this to org-mode
#+END_SRC

#+CAPTION: Tracking the true value
#+RESULTS:
[[file:.images/est_vs_truth.png]]

Cool, the performance of the fake algorithm is not that bad. I think we can be
pretty happy with it. let's see if we can gather some more information about
it's performance.

*** Examine the performance

|------------------+-------------------+-------+----------------|
|            Truth |          Estimate | Error | Absolute error |
|------------------+-------------------+-------+----------------|
|                1 |                 1 |     0 |              0 |
|                2 |                 2 |     0 |              0 |
|                3 |                 3 |     0 |              0 |
|                4 |                 4 |     0 |              0 |
|                5 |                 5 |     0 |              0 |
|                6 |                 7 |    -1 |              1 |
|                7 |                 8 |    -1 |              1 |
|                8 |                 9 |    -1 |              1 |
|                9 |                 8 |     1 |              1 |
|               10 |                 8 |     2 |              2 |
|               11 |                 9 |     2 |              2 |
|               12 |                11 |     1 |              1 |
|               13 |                11 |     2 |              2 |
|               14 |                13 |     1 |              1 |
|               15 |                14 |     1 |              1 |
|               16 |                16 |     0 |              0 |
|               17 |                15 |     2 |              2 |
|               18 |                17 |     1 |              1 |
|               19 |                20 |    -1 |              1 |
|               20 |                21 |    -1 |              1 |
|------------------+-------------------+-------+----------------|
| Number of values |                20 |       |                |
|       Mean error |               0.9 |       |                |
|             RMSE | 1.140175425099138 |       |                |
|------------------+-------------------+-------+----------------|
#+TBLFM: @2$1..@21$1='(identity remote(est-truth-data, @@#$1))::@2$2..@21$2='(identity remote(est-truth-data, @@#$2))::@2$3..@21$3=$1-$2::@2$4..@21$4='(abs (- $1 $2));N::@22$2='(length (list @2$4..@21$4));N::@23$2='(org-sbe "mean" (error @2$4..@21$4))::@24$2='(org-sbe "rmse" (estimate @2$1..@21$1) (truth @2$2..@21$2))

In order to get the values from the other table I am using [[https://orgmode.org/manual/References.html#index-remote-references-352][remote references]]. To
refer to the values of the other table.

Table
thinking of ~Windows calc~ when I hear this name. But this is something
different.

Tables also supports ~Emacs lisp~ so we can use that to calculate the absolute
error. Finally it would be nice to get a kpi like ~rmse~ to have one number for
the performance of the algorithm. Since that equation would be quite long in
Emacs lisp maybe it's time to try something else.

We can actually pass the data from the table into other code blocks, which is a
super cool. We can therefore create a block with Python code which we pass values
into in order to be able to calculate the [[https://en.wikipedia.org/wiki/Root-mean-square_deviation][rmse]]

#+NAME: rmse
#+BEGIN_SRC python :var estimate=0 :var truth=0 :exports none
import numpy as np
error = np.asarray(estimate) - np.asarray(truth)
result = np.sqrt(np.mean(np.square(error)))
return result
#+END_SRC

#+NAME: mean
#+BEGIN_SRC elisp :var error=0 :exports none
(let ((num-values (length error)))
  (/ (seq-reduce '+ error 0.0) num-values))
#+END_SRC

A second try

*** Describe the flow

I would like to describe the flow better. It would be great if we could
visualize it, perhaps in a flow chart.

#+BEGIN_SRC plantuml :file .images/flow.png :exports results
@startuml
(*) --> "Synthesize data with Elisp"

if "Improve results with post" then
  -->[Visualize the data] "Python and matplotlib"
else
  ->[Process the data] "Table formulas"
  -->[Elisp, calc and code blocks] "Visualize the flow"
  -->[plantUML] (*)
endif
@enduml
#+END_SRC

#+CAPTION: The flow of our investigation
#+RESULTS:
[[file:.images/flow.png]]

*** Export

I think that our investigation here has been a success and it would be great if
we can share the findings with our colleges. Unfortunately not all of them have
access to Org-mode and can read the information in this format. Cause as we saw
before this is just plain text so it won't look as nice outside this
environment.

Luckily Org-mode supports a lot of different exports. I am thinking for this
particular use case something common like a ~pdf~ would be a good choice. We
also would like it to look nice and professional so let's make it a ~LaTeX~
styled pdf.

To export we only need to use the function ~M-x org-latex-export-to-pdf~. There
are two other alternatives here using ~pandoc~ but I didn't find the export as
good so I will choose the first one.

One thing that did bother me though is that now I exported the file and the next
step would naturally be to look at the results. If you noticed with pandoc there
was a function called ~M-x org-pandoc-export-to-latex-pdf-and-open~. I want that
too cause if we open ~dired~ the directory editor we can see that the file is
indeed here.

But I want this automated, good thing that we are using Emacs then, let's create
the function we need.

*** Improve

So I already prepared for this and this is the elisp code we need to have a
function which also will open the pdf after the export has finished.

#+BEGIN_SRC elisp
(defun org-latex-export-to-pdf-and-open ()
"Export current buffer to LaTeX then process through to PDF and open the
resulting file"
  (interactive)
  (let* ((file-name (file-name-nondirectory buffer-file-name))
        (name (file-name-sans-extension file-name)))
  (org-latex-export-to-pdf)
  (find-file (concat name ".pdf"))))
#+END_SRC

We can see that it has the name ~pdf-and-open~. Firstly it retrieves the name of
the current file, without the extension. Then it calls the regular function and
lastly opens the exported PDF.

To install it I just open it in the popup buffer and evaluate the function and
now when I search through ~M-x~ I will find the function and it will do exactly
what we want.

*** Visual :noexport:
Some notes on how to get syntax highlighting to work for exported latex pdf
[[https://emacs.stackexchange.com/questions/20839/exporting-code-blocks-to-pdf-via-latex/20841#20841][here]] and [[https://stackoverflow.com/questions/21005885/export-org-mode-code-block-and-result-with-different-styles/21007117#21007117][here]]. The takeaways where:

- Install pygmentize
- Install minted

Installing them using pacman
#+BEGIN_SRC sh :results output
pacman -Ss "minted"
#+END_SRC

#+RESULTS:
: community/minted 2.5-1
:     Syntax highlighted source code for LaTeX

#+BEGIN_SRC sh :results output
pacman -Ss "pygmentize"
#+END_SRC

#+RESULTS:
: community/pygmentize 2.2.0-2
:     Python syntax highlighter

To be able to see which styles we can choose from we can ask ~pygmentize~
#+BEGIN_SRC sh :results output
pygmentize -L styles
#+END_SRC

#+RESULTS:
#+begin_example
Pygments version 2.2.0, (c) 2006-2017 by Georg Brandl.

Styles:
~~~~~~~
,* default:
    The default style (inspired by Emacs 22).
,* emacs:
    The default style (inspired by Emacs 22).
,* friendly:
    A modern style based on the VIM pyte theme.
,* colorful:
    A colorful style, inspired by CodeRay.
,* autumn:
    A colorful style, inspired by the terminal highlighting style.
,* murphy:
    Murphy's style from CodeRay.
,* manni:
    A colorful style, inspired by the terminal highlighting style.
,* monokai:
    This style mimics the Monokai color scheme.
,* perldoc:
    Style similar to the style used in the perldoc code blocks.
,* pastie:
    Style similar to the pastie default style.
,* borland:
    Style similar to the style used in the borland IDEs.
,* trac:
    Port of the default trac highlighter design.
,* native:
    Pygments version of the "native" vim theme.
,* fruity:
    Pygments version of the "native" vim theme.
,* bw:

,* vim:
    Styles somewhat like vim 7.0
,* vs:

,* tango:
    The Crunchy default Style inspired from the color palette from the Tango Icon Theme Guidelines.
,* rrt:
    Minimalistic "rrt" theme, based on Zap and Emacs defaults.
,* xcode:
    Style similar to the Xcode default colouring theme.
,* igor:
    Pygments version of the official colors for Igor Pro procedures.
,* paraiso-light:

,* paraiso-dark:

,* lovelace:
    The style used in Lovelace interactive learning environment. Tries to avoid the "angry fruit salad" effect with desaturated and dim colours.
,* algol:

,* algol_nu:

,* arduino:
    The Arduino® language style. This style is designed to highlight the Arduino source code, so exepect the best results with it.
,* rainbow_dash:
    A bright and colorful syntax highlighting theme.
,* abap:

#+end_example

We also need to add some code in the ~config.el~ file.
#+BEGIN_SRC elisp
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)

(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

*** Appendix

I feel that the Emacs calculator should get some more attention.

** Summary
#+OPTIONS: num:nil reveal_control:nil toc:nil
#+OPTIONS: reveal_title_slide:nil reveal_slide_number:nil
#+REVEAL_THEME: moon
#+REVEAL_TRANS: slide

*** What have we learnt?

- Org-mode makes it easy to get your information in context
- Org-mode makes it easy to export your documents into reports or presentations
