* Literate programming in Org-mode
** DONE Org-mode
CLOSED: [2018-11-19 Mon 14:37]

The first thing I will do is to show how an ~.org~ file looks in
fundamental-mode. It's actually nothing more than a text file.

*** Content

Here are some of the basics we can have a look at:

- Headings, how to create them and change them
- What kinds of lists are supported
- How tables look like
- TODO:s


**** My favorite things
1) That it's just plain text files
2) It's automatic adjustments

**** Commands

Good to know commands in Org-mode

| Commannd          | Action          |
|-------------------+-----------------|
| Tab heading       | Demotes heading |
| Shift-Tab heading | Promote heading |
| C-Enter           |                 |
| M-Enter           |                 |

** Literate programming

#+BEGIN_SRC sh
echo "hello there!"
#+END_SRC

#+RESULTS:
: hello there!

#+BEGIN_SRC elisp
(format "hello there")
#+END_SRC

#+RESULTS:
: hello there

#+BEGIN_SRC python
print("hello there")
#+END_SRC

#+RESULTS:
: None

#+BEGIN_SRC python
return "hello there"
#+END_SRC

#+RESULTS:
: hello there

#+BEGIN_SRC python :results output
print("hello there")
#+END_SRC

#+RESULTS:
: hello there

#+BEGIN_QUOTE
Org returns the contents of the standard output stream as as text results.
#+END_QUOTE

** Arguments
** Sessions
** Tangling
** Note taking

I started to take notes with Org-mode and soon I found myself reading a
programming book and realized how greatly suited Org is for that usecase.

I will open my notes file that I have and navigate to a section with notes from
the book

With Org-mode I can then easily take notes and experiment with the programming
examples that exists in the book. For me that is a perfect match which makes it
much easier for me to grasp the concepts.

However now when I am reading the notes in hindsight they aren't as clear as
they where when I took them. I think what I am missing is the actual context
from within they where taken. I guess I need to open the pdf and look for clues.

That would be if I didn't have Org-mode ... But with the package ~Org-Noter~ I
get exactly this. So I will call the function ~M-x org-noter~ and I
automatically get a split view with my notes and with the actual pdf file.
[[file:~/org/hacking_notebook.org::*The%20if%20Special%20Form][An introduction to Elisp: The if Special Form]]

** Investigation
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usemintedstyle{paraiso-light}
Let's make a fun little investigation. Assume we have some data of a signal and
we want to make an algorithm that tracks the 1-d signal. This presentation is a
little bit too short to make a real algorithm and data in so we will fake it
instead.

*** Synthesize the data
Let's use some Emacs lisp to generate the ground truth and the estimates for us:

#+BEGIN_SRC emacs-lisp :results value table :post addhdr(*this*) :exports both
  (mapcar (lambda (i)
            (list i (+ (random 4) (- i 2))))
          (number-sequence 1 20))
#+END_SRC

#+CAPTION: Truth and Estimate
#+NAME: est-truth-data
#+RESULTS:
|-------+----------|
| Truth | Estimate |
|-------+----------|
|     1 |        1 |
|     2 |        2 |
|     3 |        2 |
|     4 |        4 |
|     5 |        3 |
|     6 |        7 |
|     7 |        6 |
|     8 |        6 |
|     9 |        8 |
|    10 |        8 |
|    11 |       10 |
|    12 |       10 |
|    13 |       13 |
|    14 |       14 |
|    15 |       13 |
|    16 |       16 |
|    17 |       16 |
|    18 |       19 |
|    19 |       17 |
|    20 |       21 |

#+name: addhdr
#+begin_src emacs-lisp :var tbl=""
(cons 'hline (cons '("Truth" "Estimate") (cons 'hline tbl)))
#+end_src

Let's give the results a name so that we can reference the table later. It's
good to see the data in the table but I often find that some kind of
visualization is more powerful. It's too bad I don't know how to plot in
elisp... but I do know how to do it in Python.

*** Visualize estimate and truth
#+BEGIN_SRC python :session my-plot-session :var data=est-truth-data :results file :exports both
import numpy as np
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt

# Convert list to numpy array
truth = np.asarray(data)[:, 0]
est = np.asarray(data)[:, 1]
# Plot
fig=plt.figure()
plt.plot(truth, color="g", label="Truth")
plt.plot(est, marker="x", label="Estimate")
plt.legend(loc='upper left')
plt.xlabel("Sample")
plt.ylabel("Value")
plt.title("Tracking")
plt.savefig('.images/est_vs_truth.png')
'.images/est_vs_truth.png' # return this to org-mode
#+END_SRC

#+CAPTION: Tracking the true value
#+RESULTS:
[[file:.images/est_vs_truth.png]]

Cool, the performance of the fake algorithm is not that bad. I think we can be
pretty happy with it. let's see if we can gather some more information about
it's performance.

*** Examine the performance

|------------------+-------------------+-------+----------------|
|            Truth |          Estimate | Error | Absolute error |
|------------------+-------------------+-------+----------------|
|                1 |                 1 |     0 |              0 |
|                2 |                 2 |     0 |              0 |
|                3 |                 3 |     0 |              0 |
|                4 |                 4 |     0 |              0 |
|                5 |                 5 |     0 |              0 |
|                6 |                 7 |    -1 |              1 |
|                7 |                 8 |    -1 |              1 |
|                8 |                 9 |    -1 |              1 |
|                9 |                 8 |     1 |              1 |
|               10 |                 8 |     2 |              2 |
|               11 |                 9 |     2 |              2 |
|               12 |                11 |     1 |              1 |
|               13 |                11 |     2 |              2 |
|               14 |                13 |     1 |              1 |
|               15 |                14 |     1 |              1 |
|               16 |                16 |     0 |              0 |
|               17 |                15 |     2 |              2 |
|               18 |                17 |     1 |              1 |
|               19 |                20 |    -1 |              1 |
|               20 |                21 |    -1 |              1 |
|------------------+-------------------+-------+----------------|
| Number of values |                20 |       |                |
|       Mean error |               0.9 |       |                |
|             RMSE | 1.140175425099138 |       |                |
|------------------+-------------------+-------+----------------|
#+TBLFM: @2$1..@21$1='(identity remote(est-truth-data, @@#$1))::@2$2..@21$2='(identity remote(est-truth-data, @@#$2))::@2$3..@21$3=$1-$2::@2$4..@21$4='(abs (- $1 $2));N::@22$2='(length (list @2$4..@21$4));N::@23$2='(org-sbe "mean" (error @2$4..@21$4))::@24$2='(org-sbe "rmse" (estimate @2$1..@21$1) (truth @2$2..@21$2))

In order to get the values from the other table I am using [[https://orgmode.org/manual/References.html#index-remote-references-352][remote references]]. To
refer to the values of the other table.

Table
thinking of ~Windows calc~ when I hear this name. But this is something
different.

Tables also supports ~Emacs lisp~ so we can use that to calculate the absolute
error. Finally it would be nice to get a kpi like ~rmse~ to have one number for
the performance of the algorithm. Since that equation would be quite long in
Emacs lisp maybe it's time to try something else.

We can actually pass the data from the table into other code blocks, which is a
super cool. We can therefore create a block with Python code which we pass values
into in order to be able to calculate the [[https://en.wikipedia.org/wiki/Root-mean-square_deviation][rmse]]

#+NAME: rmse
#+BEGIN_SRC python :var estimate=0 :var truth=0 :exports none
import numpy as np
error = np.asarray(estimate) - np.asarray(truth)
result = np.sqrt(np.mean(np.square(error)))
return result
#+END_SRC

#+NAME: mean
#+BEGIN_SRC elisp :var error=0 :exports none
(let ((num-values (length error)))
  (/ (seq-reduce '+ error 0.0) num-values))
#+END_SRC

A second try

*** Describe the flow

I would like to describe the flow better. It would be great if we could
visualize it, perhaps in a flow chart.

#+BEGIN_SRC plantuml :file .images/flow.png :exports results
@startuml
(*) --> "Synthesize data with Elisp"

if "Improve results with post" then
  -->[Visualize the data] "Python and matplotlib"
else
  ->[Process the data] "Table formulas"
  -->[Elisp, calc and code blocks] "Visualize the flow"
  -->[plantUML] (*)
endif
@enduml
#+END_SRC

#+CAPTION: The flow of our investigation
#+RESULTS:
[[file:.images/flow.png]]

*** Export

I think that our investigation here has been a success and it would be great if
we can share the findings with our colleges. Unfortunately not all of them have
access to Org-mode and can read the information in this format. Cause as we saw
before this is just plain text so it won't look as nice outside this
environment.

Luckily Org-mode supports a lot of different exports. I am thinking for this
particular use case something common like a ~pdf~ would be a good choice. We
also would like it to look nice and professional so let's make it a ~LaTeX~
styled pdf.

To export we only need to use the function ~M-x org-latex-export-to-pdf~. There
are two other alternatives here using ~pandoc~ but I didn't find the export as
good so I will choose the first one.

One thing that did bother me though is that now I exported the file and the next
step would naturally be to look at the results. If you noticed with pandoc there
was a function called ~M-x org-pandoc-export-to-latex-pdf-and-open~. I want that
too cause if we open ~dired~ the directory editor we can see that the file is
indeed here.

But I want this automated, good thing that we are using Emacs then, let's create
the function we need.

*** Improve

So I already prepared for this and this is the elisp code we need to have a
function which also will open the pdf after the export has finished.

#+BEGIN_SRC elisp
(defun org-latex-export-to-pdf-and-open ()
"Export current buffer to LaTeX then process through to PDF and open the
resulting file"
  (interactive)
  (let* ((file-name (file-name-nondirectory buffer-file-name))
        (name (file-name-sans-extension file-name)))
  (org-latex-export-to-pdf)
  (find-file (concat name ".pdf"))))
#+END_SRC

We can see that it has the name ~pdf-and-open~. Firstly it retrieves the name of
the current file, without the extension. Then it calls the regular function and
lastly opens the exported PDF.

To install it I just open it in the popup buffer and evaluate the function and
now when I search through ~M-x~ I will find the function and it will do exactly
what we want.

*** Visual :noexport:
Some notes on how to get syntax highlighting to work for exported latex pdf
[[https://emacs.stackexchange.com/questions/20839/exporting-code-blocks-to-pdf-via-latex/20841#20841][here]] and [[https://stackoverflow.com/questions/21005885/export-org-mode-code-block-and-result-with-different-styles/21007117#21007117][here]]. The takeaways where:

- Install pygmentize
- Install minted

Installing them using pacman
#+BEGIN_SRC sh :results output
pacman -Ss "minted"
#+END_SRC

#+RESULTS:
: community/minted 2.5-1
:     Syntax highlighted source code for LaTeX

#+BEGIN_SRC sh :results output
pacman -Ss "pygmentize"
#+END_SRC

#+RESULTS:
: community/pygmentize 2.2.0-2
:     Python syntax highlighter

To be able to see which styles we can choose from we can ask ~pygmentize~
#+BEGIN_SRC sh :results output
pygmentize -L styles
#+END_SRC

#+RESULTS:
#+begin_example
Pygments version 2.2.0, (c) 2006-2017 by Georg Brandl.

Styles:
~~~~~~~
,* default:
    The default style (inspired by Emacs 22).
,* emacs:
    The default style (inspired by Emacs 22).
,* friendly:
    A modern style based on the VIM pyte theme.
,* colorful:
    A colorful style, inspired by CodeRay.
,* autumn:
    A colorful style, inspired by the terminal highlighting style.
,* murphy:
    Murphy's style from CodeRay.
,* manni:
    A colorful style, inspired by the terminal highlighting style.
,* monokai:
    This style mimics the Monokai color scheme.
,* perldoc:
    Style similar to the style used in the perldoc code blocks.
,* pastie:
    Style similar to the pastie default style.
,* borland:
    Style similar to the style used in the borland IDEs.
,* trac:
    Port of the default trac highlighter design.
,* native:
    Pygments version of the "native" vim theme.
,* fruity:
    Pygments version of the "native" vim theme.
,* bw:

,* vim:
    Styles somewhat like vim 7.0
,* vs:

,* tango:
    The Crunchy default Style inspired from the color palette from the Tango Icon Theme Guidelines.
,* rrt:
    Minimalistic "rrt" theme, based on Zap and Emacs defaults.
,* xcode:
    Style similar to the Xcode default colouring theme.
,* igor:
    Pygments version of the official colors for Igor Pro procedures.
,* paraiso-light:

,* paraiso-dark:

,* lovelace:
    The style used in Lovelace interactive learning environment. Tries to avoid the "angry fruit salad" effect with desaturated and dim colours.
,* algol:

,* algol_nu:

,* arduino:
    The Arduino® language style. This style is designed to highlight the Arduino source code, so exepect the best results with it.
,* rainbow_dash:
    A bright and colorful syntax highlighting theme.
,* abap:

#+end_example

We also need to add some code in the ~config.el~ file.
#+BEGIN_SRC elisp
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)

(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

*** Appendix

I feel that the Emacs calculator should get some more attention.

** Summary
#+OPTIONS: num:nil reveal_control:nil toc:nil
#+OPTIONS: reveal_title_slide:nil
#+REVEAL_THEME: moon
#+REVEAL_TRANS: slide

*** What have we learnt?

- Org-mode makes it easy to get your information in context
- Org-mode makes it easy to export your documents into reports or presentations
