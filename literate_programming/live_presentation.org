* Org-mode, literate programming in Emacs

** TODO Org-mode :emacs:org_mode:

The first thing I will do is to show how an ~.org~ file looks in
fundamental-mode. It's actually nothing more than a text file. To know more
about Org-mode visit the [[https://orgmode.org/][org-mode-site]].

*** Content

Here are some of the basics we can have a look at:

- Headings, how to create them and change them
- What kinds of lists are supported
- How tables look like
- TODO:s


**** My favorite things
1) That it's just plain text files
2) It's automatic adjustments

**** Commands

Good to know commands in Org-mode

| Command           | Action          |
|-------------------+-----------------|
| Tab heading       | Demotes heading |
| Shift-Tab heading | Promote heading |
| C-Enter           |                 |
| M-Enter           |                 |

** Literate programming


** Chaining

This is how to create a variable in bash and how to check it's value:
#+BEGIN_SRC sh :results output
MY_NAME="Niklas"
echo $MY_NAME
#+END_SRC

** Composing

Chaining blocks through ~sessions~ is useful for some types of languages like
~python~ and ~shells~. But that is not the only way. For me it can make sense to
make the blocks as small as needed. That might differ depending on context. So
we shall look more into how to compose different blocks. This is a feature
called ~noweb~.


Let's take the previous python example.


** Note taking

** Our own image

I want to build my own [[https://www.docker.com][Docker]] image and deploy an application on that image.
These are the steps to make this happen:

#+BEGIN_SRC sh :dir "/sudo::" :results none
sudo systemctl start docker
#+END_SRC

*** Build an image
:PROPERTIES:
:header-args: :results output :mkdirp yes
:END:

I would like to build a docker image with ~Python3~ installed so that I can run
my python3 code. I got the inspiration from this [[https://blog.realkinetic.com/building-minimal-docker-containers-for-python-applications-37d0272c52f3][minimal docker image]] example.

**** Requirements

We need to specify the requirements that we are demanding:
#+BEGIN_SRC text :tangle docker_image/requirements.txt
Flask>=0.12,<0.13
flask-restplus>=0.9.2,<0.10
Flask-SSLify>=0.1.5,<0.2
Flask-Admin>=1.4.2,<1.5
gunicorn>=19,<20
#+END_SRC


**** Dockerfile

The ~Dockerfile~ specifying the commands for building the image looks like this:
#+BEGIN_SRC text
FROM python:3.6-alpine

COPY requirements.txt /

RUN pip install -r /requirements.txt

COPY src/ /app
WORKDIR /app

CMD ["python", "app.py"]
#+END_SRC

~From~ create a layer from the ~python:3.6-alpine~ image:
#+NAME: dockerfile-from
#+BEGIN_SRC text
FROM python:3.6-alpine
#+END_SRC

~Copy~ adds files from your Docker client's current directory
#+NAME: dockerfile-copy
#+BEGIN_SRC text
COPY requirements.txt /
#+END_SRC

~Run~ builds your application with ~make~
#+NAME: dockerfile-run
#+BEGIN_SRC text
RUN pip install -r /requirements.txt
#+END_SRC

~Cmd~ specifies what command to run within the container
#+NAME: dockerfile-cmd
#+BEGIN_SRC text
CMD ["python", "app.py"]
#+END_SRC


The Dockerfile then becomes:
#+BEGIN_SRC text :tangle docker_image/Dockerfile :noweb yes
<<dockerfile-from>>

<<dockerfile-copy>>

<<dockerfile-run>>

COPY src/ /app
WORKDIR /app

<<dockerfile-cmd>>
#+END_SRC

**** The application

This is my application that I want to deploy in the docker
#+BEGIN_SRC python :tangle docker_image/src/app.py
for i in range(20):
    print "i has the value " + str(i)
#+END_SRC

**** Create the image

#+BEGIN_SRC sh :dir docker_image
docker build -t minimal_python .
#+END_SRC

#+RESULTS:
#+begin_example
Sending build context to Docker daemon  4.608kB
Step 1/6 : FROM python:3.6-alpine
 ---> 1d981af1e3b4
Step 2/6 : COPY requirements.txt /
 ---> Using cache
 ---> a75afff4ca55
Step 3/6 : RUN pip install -r /requirements.txt
 ---> Using cache
 ---> 363588b44974
Step 4/6 : COPY src/ /app
 ---> Using cache
 ---> 8a4ebf7146c3
Step 5/6 : WORKDIR /app
 ---> Using cache
 ---> 31a745587249
Step 6/6 : CMD ["python", "app.py"]
 ---> Using cache
 ---> b3db662ee473
Successfully built b3db662ee473
Successfully tagged minimal_python:latest
#+end_example

First we verify that the image is now available among the docker images
#+BEGIN_SRC sh
docker images
#+END_SRC

#+RESULTS:
: REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE
: niklascarlsson/minimal_python3   latest              50175d809b47        8 days ago          101MB
: minimal_python                   latest              b3db662ee473        8 days ago          101MB
: python                           3.6-alpine          1d981af1e3b4        12 days ago         74.3MB
: hello-world                      latest              4ab4c602aa5e        2 months ago        1.84kB

Nice, let's try the image
#+BEGIN_SRC sh
docker run minimal_python
#+END_SRC

#+RESULTS:


#+BEGIN_SRC sh
docker images -a
#+END_SRC

#+RESULTS:
#+begin_example
REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE
niklascarlsson/minimal_python3   latest              50175d809b47        8 days ago          101MB
<none>                           <none>              2f19f74f4b84        8 days ago          101MB
<none>                           <none>              0de70189b473        8 days ago          101MB
minimal_python                   latest              b3db662ee473        8 days ago          101MB
<none>                           <none>              31a745587249        8 days ago          101MB
<none>                           <none>              8a4ebf7146c3        8 days ago          101MB
<none>                           <none>              363588b44974        8 days ago          101MB
<none>                           <none>              a75afff4ca55        8 days ago          74.3MB
python                           3.6-alpine          1d981af1e3b4        12 days ago         74.3MB
hello-world                      latest              4ab4c602aa5e        2 months ago        1.84kB
#+end_example

#+BEGIN_SRC sh
docker rmi niklascarlsson/minimal_python3
#+END_SRC

#+RESULTS:

** Performance analysis
:PROPERTIES:
#+EXPORT_FILE_NAME: new_presentation_stripped.pdf
#+LaTeX_HEADER: \usepackage{minted}
#+LaTeX_HEADER: \usemintedstyle{paraiso-light}
:END:

Let's make a fun little investigation. Assume we have some data of a signal and
we want to make an algorithm that tracks the 1-d signal. This presentation is a
little bit too short to make a real algorithm and data in so we will fake it
instead

*** Synthesize the data

There is not room here for creating our own algorithm, so instead we will fake
the truth and estimates. To generate the true signal and the estimate we will
use a block of elisp code.
#+BEGIN_SRC emacs-lisp :results value table :exports both :post add-header(*this*)
  (mapcar (lambda (i)
            (list i (+ (random 4) (- i 2))))
          (number-sequence 1 20))
#+END_SRC

#+NAME: est-truth-data
#+CAPTION: Truth and Estimate
#+RESULTS:
|-------+----------|
| Truth | Estimate |
|-------+----------|
|     1 |       -1 |
|     2 |        3 |
|     3 |        2 |
|     4 |        2 |
|     5 |        5 |
|     6 |        5 |
|     7 |        8 |
|     8 |        6 |
|     9 |        9 |
|    10 |        8 |
|    11 |       10 |
|    12 |       11 |
|    13 |       11 |
|    14 |       14 |
|    15 |       15 |
|    16 |       14 |
|    17 |       15 |
|    18 |       16 |
|    19 |       20 |
|    20 |       18 |

In order to get the table of data more comprehensive we utilize another block to
post process the result. This block adds a header to the table.

#+name: add-header
#+begin_src emacs-lisp :var tbl=""
(cons 'hline (cons '("Truth" "Estimate") (cons 'hline tbl)))
#+end_src

#+RESULTS: add-header
: (hline (Truth Estimate) hline . )

*** Visualize estimate and truth


Here is some python code which can plot data using the matplotlib. So as a
variable to this code block we will pass the numbers from the ~est-truth-data~ block.

#+BEGIN_SRC python :session my-plot-session :var data=est-truth-data :results file :exports both
import numpy as np
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt

# Convert list to numpy array
# The need for using 1 index here is because I added the box around truth and
# estimate in the table so it interprests the first value to be truth and estimate
truth = np.asarray(data)[1:, 0]
est = np.asarray(data)[1:, 1]
# Plot
fig=plt.figure()
plt.plot(truth, color="g", label="Truth")
plt.plot(est, marker="x", label="Estimate")
plt.legend(loc='upper left')
plt.xlabel("Sample")
plt.ylabel("Value")
plt.title("Tracking")
plt.savefig('.images/est_vs_truth.png')
'.images/est_vs_truth.png' # return this to org-mode
#+END_SRC

#+CAPTION: Tracking performance
#+RESULTS:
[[file:.images/est_vs_truth.png]]

Cool, the performance of the fake algorithm is not that bad. I think we can be
pretty happy with it. let's see if we can gather some more information about
it's performance.

It's of course possible to use other languages for plotting like ~Octave~
#+BEGIN_SRC octave :results file :var data=est-truth-data[1:-1, 0:1] :exports results
truth = data(:, 1)
estimate = data(:, 2)
samples = linspace(1, 20, length(data))'

figure( 1, "visible", "off" );
hold on
plot(samples, truth, 'g-')
plot(samples, estimate, 'r-x')
print -dpng .images/performance.png -S400;
ans = ".images/performance.png";
#+END_SRC

#+RESULTS:
[[file:.images/performance.png]]

*** Performance numbers

A table can be a good way of displaying the data that we have and analyze the
values. Tables in Emacs can use ~calc~ syntax org ~elisp~ code to make the table
formulas.

#+CAPTION: Evaluation numbers
|------------------+-------------------+-------+----------------|
|            Truth |          Estimate | Error | Absolute error |
|------------------+-------------------+-------+----------------|
|                1 |                -1 |     2 |              2 |
|                2 |                 3 |    -1 |              1 |
|                3 |                 2 |     1 |              1 |
|                4 |                 2 |     2 |              2 |
|                5 |                 5 |     0 |              0 |
|                6 |                 5 |     1 |              1 |
|                7 |                 8 |    -1 |              1 |
|                8 |                 6 |     2 |              2 |
|                9 |                 9 |     0 |              0 |
|               10 |                 8 |     2 |              2 |
|               11 |                10 |     1 |              1 |
|               12 |                11 |     1 |              1 |
|               13 |                11 |     2 |              2 |
|               14 |                14 |     0 |              0 |
|               15 |                15 |     0 |              0 |
|               16 |                14 |     2 |              2 |
|               17 |                15 |     2 |              2 |
|               18 |                16 |     2 |              2 |
|               19 |                20 |    -1 |              1 |
|               20 |                18 |     2 |              2 |
|------------------+-------------------+-------+----------------|
| Number of values |                20 |       |                |
|       Mean error |              0.95 |       |                |
|             RMSE | 1.466287829861518 |       |                |
|------------------+-------------------+-------+----------------|
#+TBLFM: @2$1..@21$1='(identity remote(est-truth-data, @@#$1))::@2$2..@21$2='(identity remote(est-truth-data, @@#$2))::@2$3..@21$3=$1-$2::@2$4..@21$4='(abs (- $1 $2));N::@22$2='(length (list @2$4..@21$4));N::@23$2='(org-sbe "mean" (error @2$3..@21$3))::@24$2='(org-sbe "rmse" (estimate @2$1..@21$1) (truth @2$2..@21$2))

In order to get the values from the other table I am using [[https://orgmode.org/manual/References.html#index-remote-references-352][remote references]]. To
refer to the values of the other table. The formulas that the table accepts
should either follow the ~calc~ syntax or ~elisp~.

To calculate the mean value we can define a code block like this
#+NAME: mean
#+BEGIN_SRC elisp :var error=0 :exports none
(let ((num-values (length error)))
  (/ (seq-reduce '+ error 0.0) num-values))
  #+END_SRC

And reference it in the table formula

Any code block can of course be used, not only the ones of ~elisp~. This is
~python~ block which calculates the ~rmse~ value:
#+NAME: rmse
#+BEGIN_SRC python :var estimate=0 :var truth=0 :exports none
import numpy as np
error = np.asarray(estimate) - np.asarray(truth)
result = np.sqrt(np.mean(np.square(error)))
return result
#+END_SRC

*** Describe the flow


I would like to describe the flow better. It would be great if we could
visualize it, perhaps in a flow chart.
#+BEGIN_SRC plantuml :file .images/flow.png :exports results
    @startuml
    (*) --> "Synthesize data with Elisp"

    if "Improve results with post" then
    -->[Visualize the data] "Python and matplotlib"
    else
    ->[Process the data] "Table formulas"
    -->[Elisp, calc and code blocks] "Visualize the flow"
    -->[plantUML] (*)
    endif
    @enduml
#+END_SRC

#+RESULTS:
[[file:.images/flow.png]]

*** Emacs Calc

Now I thought that this article deserved some bonus information about Emacs
calculator. I knew about it before but writing this part got me interested into
knowing more. And I think that it was a good example of one of the aspects that
I love about Org-mode which is to be able to experiment. I found some useful
[[https://github.com/dfeich/org-babel-examples/blob/master/calc/calc.org][calc-babel-examples]] and [[http://ehneilsen.net/notebook/orgExamples/org-examples.html][org-examples]] which I took inspiration from.


#+CAPTION: Derivation with Calc
Calc is available in tables as well
| Expression | Derivative       |
|------------+------------------|
| sqrt(x)    | 0.5 / sqrt(x)    |
| cos(x)     | sin(x) pi / -180 |
| x^2        | 2 x              |
| 1/x^2      | -2 / x^3         |
#+TBLFM: $2=deriv($1,x)

Another great feature in Emacs is that if you are not happy with something,
change it. So I want a function that actually fix it at runtime.
#+BEGIN_SRC elisp
(defun org-latex-export-to-pdf-and-open ()
"Export current buffer to LaTeX then process through to PDF and open the
resulting file"
  (interactive)
  (let* ((file-name (file-name-nondirectory buffer-file-name))
        (name (file-name-sans-extension file-name)))
  (org-latex-export-to-pdf)
  (find-file (concat name ".pdf"))))
  #+END_SRC


** Summary
:PROPERTIES:
#+EXPORT_FILE_NAME: summary.html
:END:
#+OPTIONS: num:nil reveal_control:nil toc:nil
#+OPTIONS: reveal_title_slide:nil reveal_slide_number:nil
#+REVEAL_THEME: black
#+REVEAL_TRANS: slide

*** Org-mode + literate programming

#+ATTR_REVEAL: :frag (roll-in)
- ~Context~ (connect everything needed)
- ~Documentation~ (made easy)
- ~Hackable~ (change what we don't like)
- ~Exports~ (replaces other programs)

*** Thanks for listening

[[./images/org-mode-logo.jpg]]
*** The End? ...
[[./images/org-hugo-last.jpg]]
*** Blogging :noexport:

Let's turn something that we have made here into a blog post :)
[[file:~/src/emacs-blog/content-org/content.org::*Org%20export%20pdf%20latex][Org export pdf latex]]
