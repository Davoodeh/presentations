#+TITLE: Emacs
# Global settings
#+REVEAL_THEME: black
#+REVEAL_TRANS: convex
#+REVEAL_EXTRA_OPTIONS: width:1920, height:1200, margin:0.1, controls:true, slide_number:false, center:true
#+REVEAL_EXTRA_CSS: ./presentation.css
#+OPTIONS: num:nil toc:nil reveal_global_footer:nil
#+REVEAL_SLIDE_FOOTER:

# Title page
#+Subtitle: The Lisp Machine
#+REVEAL_TITLE_SLIDE: <h1>%t</h1><h3>%s</h3>
#+REVEAL_TITLE_SLIDE_BACKGROUND: ./images/lambda.jpg

* Philosophy
** Free software

#+BEGIN_NOTES
The idea of free software is that the user should have the freedom to:
#+END_NOTES

#+ATTR_REVEAL: :frag (roll-in)
- Run the program as you wish
- Study the program and change it
- Redistribute copies to help others
- Distribute copies of modified versions

** Empowering users

#+BEGIN_NOTES
The goal is to empower users. If that is your goal then there are some design
choices that will be made based on that ideal:
- accessing the source code must be easy
- reading documentation must be easy
- changing code, even core, must be easy
#+END_NOTES

* Lisp Machine

#+BEGIN_NOTES
I think the best way to describe Emacs is a Lisp Machine. Historically that
might not be entirely accurate, because lisp machines of the 80s were really
high tech completely hackable computers. But Emacs comes pretty close.

In a way I think a machine is suitable, like a virtual machine. But this one is
built on lisp and it's a programmable and modifiable computing environment.
#+END_NOTES

** Lisp

#+BEGIN_NOTES
Lisp is a functional programming language. Known for it's little syntax and high
density of parentheses.

In Emacs the dialect is Emacs Lisp. There are many Lisps out there like common
lisp, scheme, clojure.
#+END_NOTES

#+BEGIN_NOTES
This is an example of a lisp expression. It takes a function, + and applies it
to a sequence of data to calculate the sum of the list.
#+END_NOTES

#+BEGIN_SRC elisp
(seq-reduce #'+ (number-sequence 1 100) 0)
#+END_SRC

* The interface

#+BEGIN_NOTES
Emacs and Lisp excels at text processing. And as we will see it manages to
take the command line or text based interfaces and improve them.

Many successful packages uses this approach:
- Man
- Dired
- Magit
#+END_NOTES

* Workflows

#+BEGIN_NOTES
So far I have talked about the theoretical aspects. But what does it mean in
practice. What kind of workflows would this enable, and how do I use Emacs?
#+END_NOTES

** Keyboard driven :noexport:

#+BEGIN_NOTES
Emacs and many of it's packages provides excellent keyboard interfaces. You can
still use the mouse in Emacs but instead of relying upon the user to use it, it
offers clever ways to get working effectively with your keyboard.
#+END_NOTES

#+BEGIN_NOTES
Some examples are:
- ivy (the actions, it's integration with avy)
- swiper
- avy
#+END_NOTES

** Powered up interfaces                                             :noexport:

#+BEGIN_NOTES
Some examples are:
- dired
- wgrep
- man
- lookup (docsets/online)
- gerrit-ci
#+END_NOTES

** Lisp

#+BEGIN_NOTES
Everywhere there is lisp (means there are ways to hack):
- .dir-locals
- locals in org-files
- snippets
- a lisp powered shell (eshell)
#+END_NOTES

** Dynamic

#+BEGIN_NOTES
The lisp environment is extremely dynamic:
- buffer narrowing
- winner mode
- popup buffers
- hackable in realtime
- implement new functionality (multi-language vim)
#+END_NOTES

** Power level features

#+BEGIN_NOTES
I should probably put this somewhere else and rephrase, but:
- tramp
- undo-tree
#+END_NOTES

** Org-mode

#+BEGIN_NOTES
Org-mode, the Emacs gateway drug to Emacs. Powerfull beyond comprehension.
- literate-programming
- presentation
- documentation
- blog
#+END_NOTES

** Magit

#+BEGIN_NOTES
Git is a powerful tool for version control, and it's easy to use it through the
cli ... but doing advance stuff quickly becomes difficult:
- magit is the true git porcelin, wrapping almost everything there is in git and
  put the power in your hands with quickly accessible commands most of the times
  just requiring two keypresses.
#+END_NOTES

** Everything in Emacs
